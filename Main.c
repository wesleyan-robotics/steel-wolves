#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     magnetic,       sensorHiTechnicMagnetic)
#pragma config(Motor,  motorA,          leftArm,       tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          rightArm,      tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     RightWheel,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     LeftWheel,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
//#include "HTMAG-driver.h"

void initializeRobot()
{
	// Place code here to initialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	return;
}

void joystickDebug()
{
	nxtDisplayCenteredTextLine(0, "Joy1 X1: %i",joystick.joy1_x1);
	nxtDisplayCenteredTextLine(1, "Joy1 Y1: %i",joystick.joy1_y1);
	nxtDisplayCenteredTextLine(2, "Joy1 X2: %i",joystick.joy1_x2);
	nxtDisplayCenteredTextLine(3, "Joy1 Y2: %i",joystick.joy1_y2);
	nxtDisplayCenteredTextLine(4, "Joy2 X1: %i",joystick.joy2_x1);
	nxtDisplayCenteredTextLine(5, "Joy2 Y1: %i",joystick.joy2_y1);
	nxtDisplayCenteredTextLine(6, "Joy2 X2: %i",joystick.joy2_x2);
	nxtDisplayCenteredTextLine(7, "Joy2 Y2: %i",joystick.joy2_y2);
}

int convertJoystickToMotor(int power)
{
	return ((power * 100) / 127);
}

int convertJoystickToMotorAvg(int x, int y)
{
	return ((((x + y) / 2) * 100) / 127);
}

void setDirection()
{
	int xDirection = 0;
	int yDirection = 0;

	// Get the directions and the powers
	if (joystick.joy1_x1 > 0) // Right
	{
		xDirection = ConvertJoystickToMotor(joystick.joy1_x1);
	}
	else // Left
	{
		xDirection = ConvertJoystickToMotor(-1 * joystick.joy1_x1);
	}

	if (joystick.joy1_y1 > 0) // Forward
	{
		yDirection = 1;
	}
	else // Backwards
	{
		yDirection = -1;
	}

	// Set the motors to the powers
  motor[RightWheel] = (yDirection * xDirection / 10);
  motor[LeftWheel] = (yDirection * xDirection / 10);
}

void setDeadZones()
{
	// Set dead-zones if
	if((joystick.joy1_y1 <= 5) && (joystick.joy1_y1 >= -5)) { joystick.joy1_y1 = 0; }
	if((joystick.joy1_x1 <= 5) && (joystick.joy1_x1 >= -5)) { joystick.joy1_y1 = 0; }
}

task main()
{
	/*
	while(true)
	{
	motor[motorB] = 10;
	wait1Msec(1000);
	motor[motorA] = 10;
	wait1Msec(1000);
	}
	*/
	initializeRobot();

	waitForStart();   // wait for start of tele-op phase
	while(true)
	{
		getJoystickSettings(joystick);

		setDeadZones();
		setDirectionX();
		setDirectionY();

		joystickDebug();
	}
}
