#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     magnetic,       sensorHiTechnicMagnetic)
#pragma config(Motor,  motorA,          leftArm,       tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          rightArm,      tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     RightWheel,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     LeftWheel,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
//#include "HTMAG-driver.h"

void initializeRobot()
{
	// Place code here to initialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	return;
}

void joystickDebug()
{
	nxtDisplayCenteredTextLine(0, "Joy1 X1: %i",joystick.joy1_x1);
	nxtDisplayCenteredTextLine(1, "Joy1 Y1: %i",joystick.joy1_y1);
	nxtDisplayCenteredTextLine(2, "Joy1 X2: %i",joystick.joy1_x2);
	nxtDisplayCenteredTextLine(3, "Joy1 Y2: %i",joystick.joy1_y2);
	nxtDisplayCenteredTextLine(4, "Joy2 X1: %i",joystick.joy2_x1);
	nxtDisplayCenteredTextLine(5, "Joy2 Y1: %i",joystick.joy2_y1);
	nxtDisplayCenteredTextLine(6, "Joy2 X2: %i",joystick.joy2_x2);
	nxtDisplayCenteredTextLine(7, "Joy2 Y2: %i",joystick.joy2_y2);
}

int convertJoystickToMotor(const int power)
{
	return ((power * 100) / 127);
}

int convertJoystickToMotorAvg(const int x, const int y)
{
	return ((((x + y) / 2) * 100) / 127);
}

void setDirection()
{
	int x = joystick.joy1_x1;
	int y = joystick.joy1_y1;

	int isForward = 0;

	if (y > 0)
	{
		isForward = 1;
	}
	else
	{
		isForward = -1;
	}

	// Forward dead-zone
	if (x > -25 && x < 25)
	{
		motor[RightWheel] = y;
		motor[LeftWheel] = y;
	}
	else
		{
		// Get the directions and the powers
		if (x > 0) // Right
		{
			motor[RightWheel] = x * isForward * y;
			motor[LeftWheel] = x * isForward * (y/100);
		}
		else // Left
		{
			motor[RightWheel] = x * isForward * (y/100);
			motor[LeftWheel] = x * isForward * y;
		}
	}
}

task main()
{
	/*
	while(true)
	{
	motor[motorB] = 10;
	wait1Msec(1000);
	motor[motorA] = 10;
	wait1Msec(1000);
	}
	*/
	initializeRobot();

	waitForStart();   // wait for start of tele-op phase
	while(true)
	{
		getJoystickSettings(joystick);

		setDirection();
		joystickDebug();
	}
}
