#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     SonarBottom,    sensorSONAR)
#pragma config(Sensor, S3,     SonarTop,       sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftWheel,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     AccordionTop,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     AccordionBottom, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     RightWheel,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Motor.h"
#include "Joystick.h"
#include "Sonar.h"

const bool TESTING_AUTONOMOUS = false;

const int ACCORDION_SPEED_UP = 80;
const int ACCORDION_SPEED_DOWN = 50;

const float SPEED_LIMIT_FACTOR = 0.75;
const float ACCORDION_RATIO = 3.3921; /* Ratio between rotations from the small gear to the bigger gear */

void initializeRobot()
{
    initMotors(LeftWheel, RightWheel);
    initSonars(SonarBottom, SonarTop);
}

void displayJoystickDebug()
{
	nxtDisplayTextLine(0, "Joy1: (%i, %i)", joystick.joy1_x1, joystick.joy1_y1);
	nxtDisplayTextLine(1, "Joy2: (%i, %i)", joystick.joy1_y2, joystick.joy1_x2);
	nxtDisplayTextLine(2, "Joy1: Buttons:");
	nxtDisplayTextLine(3, " 1:%i 2:%i 3:%i 4:%i", joy1Btn(1), joy1Btn(2), joy1Btn(3), joy1Btn(4));
	nxtDisplayTextLine(4, " 5:%i 6:%i 7:%i 8:%i", joy1Btn(5), joy1Btn(6), joy1Btn(7), joy1Btn(8));
	nxtDisplayTextLine(5, " 9:%i 10:%i 11:%i", joy1Btn(9), joy1Btn(10), joy1Btn(11));
	nxtDisplayTextLine(6, " 12:%i", joy1Btn(12));
	nxtDisplayTextLine(7, "Joy2 TopHat: %i", joystick.joy1_TopHat);
}

/* This uses the new method of driving where:
 * LEFT Joystick  - Moves forward and backward
 * RIGHT Joystick - Moves left and right
 */
void setDirectionFromJoystick()
{
	int lWheel;
	int rWheel;
	int vertical = convertJoystickToMotor(joystick.joy1_y1);
	int horizontal = convertJoystickToMotor(joystick.joy1_x2);

	if (isInDeadzone(vertical))
	{
		if (!isInDeadzone(horizontal)) {
			vertical = 5;
		} else {
			setPower(0);
			return;
		}
	}
	setInDeadzone(&horizontal);

	lWheel = (vertical + horizontal) * SPEED_LIMIT_FACTOR;
	rWheel = (vertical - horizontal) * SPEED_LIMIT_FACTOR;

	setPower(lWheel, rWheel);
}

void setAccordionFromJoystick()
{
	// Increase 90 deg
	if (joystick.joy1_TopHat == (short)DPAD_UP) {
		motor[AccordionTop] = -ACCORDION_SPEED_UP;
		motor[AccordionBottom] = -ACCORDION_SPEED_UP / ACCORDION_RATIO;
	} else if (joystick.joy1_TopHat == (short)DPAD_DOWN) {
		motor[AccordionTop] = ACCORDION_SPEED_DOWN;
		motor[AccordionBottom] = ACCORDION_SPEED_DOWN / ACCORDION_RATIO;
	} else {
		motor[AccordionTop] = 0;
		motor[AccordionBottom] = 0;
	}
}

void startWithAutonomous()
{
	// TODO: Need to detect when we can control the robot with the joysticks
    //       so that we can return from this
	//startScan();

	while(true)
	{
		getJoystickSettings(joystick);

		setDirectionFromJoystick();
		setAccordionFromJoystick();
		displaySonarDebug();
	}
}

task main()
{
	initializeRobot();
	waitForStart();

	if (TESTING_AUTONOMOUS) {
		startScan();
		return;
	} else {
		startWithAutonomous();
	}
}
